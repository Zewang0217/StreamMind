> BY KIMI AI

kimiå»ºè®®ï¼š

  ğŸ¯ é¡¹ç›®æ¶æ„åˆ†æ

  âœ… æ¶æ„è½¬å‹çš„åˆç†æ€§

  ä½ çš„é¡¹ç›®ä»ä¼ ç»Ÿçš„ producer/consumer/stream æ¶æ„è½¬å‹ä¸ºæ›´ä¸“ä¸šçš„å¾®æœåŠ¡æ¶æ„ï¼ˆcollector-service, stream-analyzer, alert-service
  ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æ¼”è¿›ï¼š

  ä¼˜åŠ¿ï¼š

  â€¢ èŒè´£åˆ†ç¦»æ›´æ¸…æ™°ï¼šæ•°æ®é‡‡é›†ã€æµå¤„ç†ã€é¢„è­¦å®Œå…¨è§£è€¦
  â€¢ ç‹¬ç«‹éƒ¨ç½²æ‰©å±•ï¼šå„æ¨¡å—å¯æ ¹æ®è´Ÿè½½ç‹¬ç«‹æ‰©ç¼©å®¹
  â€¢ æŠ€æœ¯æ ˆçµæ´»ï¼šä¸åŒæ¨¡å—å¯é€‰æ‹©æœ€é€‚åˆçš„æŠ€æœ¯æ–¹æ¡ˆ

  ğŸ“‹ æ ¸å¿ƒæ¨¡å—åˆ†æ

  1. Commonæ¨¡å— - â­â­â­â­â­

  äº®ç‚¹ï¼š

  // ä¼˜ç§€çš„record + Builderæ¨¡å¼è®¾è®¡
  @Builder
  public record SocialMessage (
      String messageId,
      String source,
      String topic,
      String userId,
      @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
      LocalDateTime timestamp,
      String content,
      int interactionCount
  ) {}

  å»ºè®®ï¼š

  â€¢ âœ… å·²ç»å¾ˆå¥½åœ°ä½¿ç”¨äº†Java 17çš„recordç±»å‹
  â€¢ âœ… Builderæ¨¡å¼å¢åŠ äº†åˆ›å»ºçµæ´»æ€§
  â€¢ ğŸ’¡ å»ºè®®è¡¥å……ï¼šæ·»åŠ å­—æ®µéªŒè¯æ³¨è§£ï¼Œå¦‚@NotNullã€@Sizeç­‰

  2. Collector-Service - â­â­â­â­

  äº®ç‚¹ï¼š

  â€¢ ä½¿ç”¨OpenCSVä¼˜é›…å¤„ç†CSVæ•°æ®
  â€¢ åˆç†çš„å®šæ—¶ä»»åŠ¡é…ç½®ï¼ˆ10msé—´éš”ï¼Œæ¯æ¬¡10æ¡ï¼‰
  â€¢ æ™ºèƒ½çš„æ•°æ®å¾ªç¯ä½¿ç”¨æœºåˆ¶

  å»ºè®®ï¼š

  // å½“å‰ä»£ç 
  @Scheduled(fixedDelay = 10)
  public void sendBatchMessages() {
      // æ¯10mså‘é€10æ¡ï¼Œå¯èƒ½è¿‡äºé¢‘ç¹
  }

  ğŸ’¡ ä¼˜åŒ–å»ºè®®ï¼š

  @Scheduled(fixedDelayString = "${collector.send-interval:100}") // å¯é…ç½®åŒ–
  public void sendBatchMessages() {
      int batchSize = Integer.parseInt(env.getProperty("collector.batch-size", "10"));
      // æ·»åŠ å‘é€é€Ÿç‡æ§åˆ¶
      RateLimiter rateLimiter = RateLimiter.create(1000); // æ¯ç§’æœ€å¤š1000æ¡
  }

  3. Stream-Analyzer - â­â­â­â­â­

  äº®ç‚¹ï¼š

  â€¢ ä¼˜ç§€çš„æ‰¹é‡å¤„ç†è®¾è®¡ï¼ˆ50æ¡æˆ–10ç§’è§¦å‘ï¼‰
  â€¢ å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œèµ„æºæ¸…ç†
  â€¢ ä½¿ç”¨Kafka Streamsçš„Processor APIï¼Œçµæ´»æ€§é«˜

  å»ºè®®ï¼š

  // å½“å‰åˆ·æ–°é—´éš”è®¾ç½®
  private static final Duration FLUSH_INTERVAL = Duration.ofSeconds(10);

  // å»ºè®®æ”¹ä¸ºå¯é…ç½®
  @Value("${analyzer.batch.size:50}")
  private int batchSize;

  @Value("${analyzer.flush.interval.seconds:10}")
  private Duration flushInterval;

  ğŸš¨ å…³é”®é—®é¢˜ä¸æ”¹è¿›å»ºè®®

  4. Alert-Serviceæ¨¡å—ç¼ºå¤± â­â­â­

  ç°çŠ¶ï¼š åªæœ‰ä¸€ä¸ªç©ºçš„åº”ç”¨å¯åŠ¨ç±» å»ºè®®å®ç°ï¼š

  @Service
  public class AlertProcessor {

      @KafkaListener(topics = KafkaConstants.ANALYZED_STREAM_TOPIC)
      public void processAnalyzedMessage(AnalyzedMessage message) {
          // æƒ…æ„Ÿé˜ˆå€¼é¢„è­¦
          if (message.sentimentScore() < -0.5) {
              sendAlert("NEGATIVE_SENTIMENT", message);
          }
          // æ¯’æ€§å†…å®¹é¢„è­¦
          if (message.toxicityScore() > 0.7) {
              sendAlert("HIGH_TOXICITY", message);
          }
      }

      private void sendAlert(String alertType, AnalyzedMessage message) {
          Alert alert = Alert.builder()
              .messageId(message.messageId())
              .alertType(alertType)
              .severity(calculateSeverity(message))
              .timestamp(LocalDateTime.now())
              .build();

          kafkaTemplate.send(KafkaConstants.ALERT_EVENTS_TOPIC, alert);
      }
  }

  5. çŠ¶æ€ç®¡ç†ä¸ç›‘æ§ç¼ºå¤± â­â­â­

  å»ºè®®æ·»åŠ ï¼š

  @Component
  public class StreamMetrics {

      private final MeterRegistry registry;

      public void recordProcessingLatency(long latencyMs) {
          registry.timer("stream.processing.latency").record(latencyMs, TimeUnit.MILLISECONDS);
      }

      public void recordBatchSize(int size) {
          registry.gauge("stream.batch.size", size);
      }
  }

  6. é…ç½®ç®¡ç†ä¼˜åŒ– â­â­â­â­

  å½“å‰ï¼š ç¡¬ç¼–ç é…ç½®è¾ƒå¤š å»ºè®®ï¼š ä½¿ç”¨Spring Booté…ç½®ä½“ç³»

  # application.yml
  collector:
    send-interval: 100ms
    batch-size: 10
    data-source: classpath:csv/sample-data.csv

  analyzer:
    batch-size: 50
    flush-interval: 10s
    ai-service:
      timeout: 30s
      retry-attempts: 3

  alert:
    sentiment-threshold: -0.5
    toxicity-threshold: 0.7

  7. é”™è¯¯å¤„ç†ä¸é‡è¯•æœºåˆ¶ â­â­â­

  å½“å‰ï¼š åªæœ‰ç®€å•çš„é™çº§å¤„ç† å»ºè®®å¢å¼ºï¼š

  @Retryable(value = {AiServiceException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
  public List<AnalyzedMessage> analyzeBatch(List<SocialMessage> messages) {
      // AIåˆ†æé€»è¾‘
  }

  @Recover
  public List<AnalyzedMessage> recoverFromAiFailure(AiServiceException e, List<SocialMessage> messages) {
      log.error("AIæœåŠ¡è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é™çº§ç­–ç•¥");
      return messages.stream()
          .map(this::createNeutralAnalysis)
          .collect(Collectors.toList());
  }

  ğŸ¯ ä¸å¼€å‘æ–‡æ¡£çš„å¯¹åº”å…³ç³»

  ä½ çš„å®ç°å¾ˆå¥½åœ°å¯¹åº”äº†å¼€å‘æ–‡æ¡£çš„è§„åˆ’ï¼š

   å¼€å‘æ–‡æ¡£é˜¶æ®µ    å®é™…å®ç°                        å®Œæˆåº¦
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
   V1.0 åŸºç¡€æµç¨‹   âœ… Collector+Analyzer+åŸºç¡€DTO   80%
   V1.5 å†å²åˆ†æ   âŒ å¾…å®ç°                       0%
   V2.0 å®æ—¶äº¤äº’   âŒ å¾…å®ç°                       0%

  ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®ä¼˜å…ˆçº§

  ğŸ”¥ é«˜ä¼˜å…ˆçº§ï¼ˆç«‹å³å¤„ç†ï¼‰

  8. å®Œå–„Alert-Serviceï¼šå®ç°é¢„è­¦é€»è¾‘å’Œé˜ˆå€¼åˆ¤æ–­
  9. æ·»åŠ é…ç½®ç®¡ç†ï¼šæ›¿æ¢ç¡¬ç¼–ç é…ç½®
  10. å¢å¼ºé”™è¯¯å¤„ç†ï¼šå®ç°é‡è¯•å’Œé™çº§æœºåˆ¶

  âš¡ ä¸­ä¼˜å…ˆçº§ï¼ˆè¿‘æœŸå¤„ç†ï¼‰

  11. æ·»åŠ ç›‘æ§æŒ‡æ ‡ï¼šé›†æˆMicrometer + Prometheus
  12. å®ç°æ•°æ®æŒä¹…åŒ–ï¼šæ·»åŠ MySQLé›†æˆ
  13. æ·»åŠ APIæ¥å£ï¼šæä¾›æŸ¥è¯¢å’Œåˆ†ææ¥å£

  ğŸ”® ä½ä¼˜å…ˆçº§ï¼ˆé•¿æœŸè§„åˆ’ï¼‰

  14. å®ç°V1.5å†å²åˆ†æï¼šæ·»åŠ çŠ¶æ€å­˜å‚¨å’Œæ‰¹é‡å¤„ç†
  15. å®ç°V2.0å®æ—¶äº¤äº’ï¼šé›†æˆWebSocket
  16. æ€§èƒ½ä¼˜åŒ–ï¼šå¼‚æ­¥å¤„ç†ã€ç¼“å­˜ä¼˜åŒ–

  ğŸ’¡ æ€»ç»“

  ä½ çš„é¡¹ç›®æ¶æ„è®¾è®¡ä¼˜ç§€ï¼Œä»£ç è´¨é‡å¾ˆé«˜ï¼Œç‰¹åˆ«æ˜¯ï¼š

  â€¢ âœ… åˆç†ä½¿ç”¨Java 17æ–°ç‰¹æ€§ï¼ˆrecordã€varï¼‰
  â€¢ âœ… æ¨¡å—èŒè´£åˆ’åˆ†æ¸…æ™°
  â€¢ âœ… æµå¤„ç†è®¾è®¡åˆç†ï¼ˆæ‰¹å¤„ç†+æ—¶é—´çª—å£ï¼‰
  â€¢ âœ… å¼‚å¸¸å¤„ç†å®Œå–„

  ä¸»è¦æ”¹è¿›ç©ºé—´ï¼š Alert-Serviceè¡¥å…¨ã€é…ç½®ç®¡ç†ã€ç›‘æ§æŒ‡æ ‡ã€‚ç»§ç»­ä¿æŒè¿™ç§é«˜è´¨é‡çš„ä»£ç é£æ ¼ï¼



---


processoréƒ¨åˆ†

## ä¸€ã€æ‰¹å¤„ç†ä¼˜åŒ–ï¼šä»æ‰‹åŠ¨åˆ°çª—å£èšåˆ

ä½ å½“å‰çš„æ‰¹å¤„ç†å®ç°å­˜åœ¨å‡ ä¸ªé—®é¢˜ï¼š

- **çŠ¶æ€ç®¡ç†è„†å¼±**ï¼š`buffer` åœ¨å†…å­˜ä¸­ï¼Œåº”ç”¨é‡å¯ä¼šä¸¢å¤±
    
- **æ— æ³•æ‰©å±•**ï¼šå¤šå®ä¾‹æ—¶æ¯ä¸ªå®ä¾‹ç‹¬ç«‹ç¼“å†²ï¼Œæ— æ³•å…¨å±€æ‰¹å¤„ç†
    
- **ç¼ºä¹å®¹é”™**ï¼šæ²¡æœ‰åˆ©ç”¨ Kafka Streams çš„çŠ¶æ€å­˜å‚¨å’Œæ£€æŸ¥ç‚¹æœºåˆ¶
    
- **èƒŒå‹éš¾æ§**ï¼šæ‰¹é‡å¤§å°å›ºå®šï¼Œæ— æ³•è‡ªé€‚åº”æµé‡å˜åŒ–
    

### **ä¼˜åŒ–æ–¹æ¡ˆï¼šçª—å£èšåˆ + å®šæ—¶è§¦å‘**

java

å¤åˆ¶

```java
// åœ¨ KafkaStreamConfig.java ä¸­æ›¿æ¢åŸæœ‰å®ç°
@Bean
public KStream<String, AnalyzedMessage> optimizedStream(
        StreamsBuilder streamsBuilder, 
        MockAIService mockAIService) {
    
    JsonSerde<SocialMessage> messageSerde = new JsonSerde<>(SocialMessage.class);
    JsonSerde<AnalyzedMessage> analyzedSerde = new JsonSerde<>(AnalyzedMessage.class);
    messageSerde.configure(Map.of("spring.json.trusted.packages", "*"), false);
    analyzedSerde.configure(Map.of("spring.json.trusted.packages", "*"), false);

    // 1. åˆ›å»ºè¾“å…¥æµï¼ˆä¿æŒä¸å˜ï¼‰
    KStream<String, SocialMessage> sourceStream = streamsBuilder.stream(
        KafkaConstants.SOCIAL_MESSAGES_TOPIC,
        Consumed.with(Serdes.String(), messageSerde)
    );

    // 2. å¯é€‰ï¼šrepartition ç¡®ä¿å‡åŒ€åˆ†å¸ƒï¼ˆè‹¥keyåˆ†å¸ƒä¸å‡ï¼‰
    // keyä¸ºnullæˆ–åˆ†å¸ƒä¸å‡æ—¶ï¼Œé€šè¿‡repartitionå®ç°è´Ÿè½½å‡è¡¡
    KStream<String, SocialMessage> repartitionedStream = sourceStream
        .repartition(Repartitioned.with(Serdes.String(), messageSerde)
            .withName("ai-analysis-repartition")
            .withNumberOfPartitions(6)); // æ˜¾å¼æŒ‡å®šåˆ†åŒºæ•°

    // 3. æŒ‰æ—¶é—´çª—å£èšåˆï¼ˆæ ¸å¿ƒä¼˜åŒ–ï¼‰
    KStream<String, List<SocialMessage>> windowedBatchStream = repartitionedStream
        .groupByKey() // æŒ‰keyåˆ†ç»„ï¼Œè‹¥key=nullåˆ™æ‰€æœ‰æ¶ˆæ¯åˆ°ä¸€ä¸ªåˆ†åŒº
        .windowedBy(TimeWindows.ofSizeAndGrace(Duration.ofSeconds(10), Duration.ofSeconds(2)))
        .aggregate(
            ArrayList::new, // åˆå§‹åŒ–ç´¯åŠ å™¨
            (key, message, aggregate) -> { // èšåˆå‡½æ•°
                aggregate.add(message);
                return aggregate;
            },
            Materialized.<String, List<SocialMessage>, WindowStore<Bytes, byte[]>>as("batch-store")
                .withKeySerde(Serdes.String())
                .withValueSerde(new ListSerde<>(messageSerde)) // è‡ªå®šä¹‰Liståºåˆ—åŒ–
        )
        .toStream()
        .flatMap((windowedKey, messageList) -> {
            // å°†çª—å£ç»“æœè½¬æ¢ä¸ºç‹¬ç«‹è®°å½•
            return messageList.stream()
                .map(msg -> KeyValue.pair(windowedKey.key(), msg))
                .collect(Collectors.toList());
        });

    // 4. è°ƒç”¨AIæœåŠ¡ï¼ˆä½¿ç”¨ transform è€Œé processï¼Œä¾¿äºçŠ¶æ€ç®¡ç†ï¼‰
    KStream<String, AnalyzedMessage> analyzedStream = windowedBatchStream
        .transform(() -> new BatchAnalysisTransformer(mockAIService), "batch-store");

    // 5. è¾“å‡ºç»“æœï¼ˆä¿æŒä¸å˜ï¼‰
    analyzedStream.to(
        KafkaConstants.ANALYZED_STREAM_TOPIC,
        Produced.with(Serdes.String(), analyzedSerde)
    );

    return analyzedStream;
}
```

### **å…³é”®æ”¹è¿›ç‚¹**

è¡¨æ ¼

å¤åˆ¶

|ç‰¹æ€§|æ‰‹åŠ¨å®ç°|çª—å£èšåˆä¼˜åŒ–|
|:--|:--|:--|
|**çŠ¶æ€æŒä¹…åŒ–**|å†…å­˜bufferï¼Œæ˜“å¤±|RocksDBçŠ¶æ€å­˜å‚¨ï¼Œå¯æ¢å¤|
|**å®¹é”™æ€§**|æ— ï¼Œé‡å¯ä¸¢å¤±|æ”¯æŒæ°å¥½ä¸€æ¬¡è¯­ä¹‰|
|**æ‰©å±•æ€§**|å¤šå®ä¾‹ä¸ååŒ|è‡ªåŠ¨åˆ†åŒºåˆ†é…å’Œè´Ÿè½½å‡è¡¡|
|**èƒŒå‹**|å›ºå®šsize=50|æ—¶é—´çª—å£åŠ¨æ€è°ƒæ•´|
|**ç›‘æ§**|è‡ªå®šä¹‰æ—¥å¿—|å†…ç½®æŒ‡æ ‡ï¼ˆ`kafka.streams`æŒ‡æ ‡ï¼‰|

### **å®ç°è¦ç‚¹**

1. **è‡ªå®šä¹‰ ListSerde**ï¼ˆå¿…éœ€ï¼‰ï¼š
    

java

å¤åˆ¶

```java
public class ListSerde<T> implements Serde<List<T>> {
    private final Serde<T> innerSerde;
    // å®ç°åºåˆ—åŒ–/ååºåˆ—åŒ–ï¼Œä½¿ç”¨ JSON æ•°ç»„æ ¼å¼
}
```

2. **BatchAnalysisTransformer**ï¼ˆè½¬æ¢å™¨ï¼‰ï¼š
    

java

å¤åˆ¶

```java
public class BatchAnalysisTransformer implements Transformer<String, SocialMessage, KeyValue<String, AnalyzedMessage>> {
    private ProcessorContext context;
    private KeyValueStore<String, List<SocialMessage>> store;
    private MockAIService service;

    @Override
    public void init(ProcessorContext context) {
        this.context = context;
        this.store = context.getStateStore("batch-store");
        // æ³¨å†Œ30ç§’ä¸€æ¬¡çš„punctuator
        context.schedule(Duration.ofSeconds(30), PunctuationType.STREAM_TIME, this::flush);
    }

    private void flush(long timestamp) {
        // ä»storeä¸­è¯»å–æ‰€æœ‰æ¶ˆæ¯ï¼Œè°ƒç”¨AIæœåŠ¡ï¼Œforwardç»“æœ
    }
}
```

3. **Repartition çš„ä½œç”¨**ï¼š
    
    - å½“æ¶ˆæ¯çš„ key ä¸º null æˆ–åˆ†å¸ƒä¸å‡æ—¶ï¼Œ`repartition()` å¯ç¡®ä¿æ•°æ®å‡åŒ€åˆ†å¸ƒåˆ°å¤šä¸ªåˆ†åŒº
        
    - **å¿…é¡»æ˜¾å¼æŒ‡å®šåˆ†åŒºæ•°**ï¼Œå¦åˆ™æ²¿ç”¨è¾“å…¥ä¸»é¢˜åˆ†åŒºæ•°
        

---

## äºŒã€é˜ˆå€¼è°ƒæ•´ç­–ç•¥

å½“å‰ `MockAIService` ä¸­çš„é˜ˆå€¼æ˜¯**ç¡¬ç¼–ç **çš„ï¼Œç”Ÿäº§ç¯å¢ƒéœ€è¦**åŠ¨æ€å¯è°ƒ**ï¼š

### **1. é…ç½®æ–‡ä»¶åŒ–ï¼ˆåŸºç¡€ï¼‰**

java

å¤åˆ¶

```java
@Component
public class AnalysisThresholdConfig {
    @Value("${analysis.sentiment.positive:0.3}")
    private double positiveThreshold;

    @Value("${analysis.sentiment.negative:-0.3}")
    private double negativeThreshold;

    @Value("${analysis.toxicity.warning:0.7}")
    private double toxicityWarningThreshold;

    // getters
}
```

yaml

å¤åˆ¶

```yaml
# application.yml
analysis:
  sentiment:
    positive: 0.4   # æ›´ä¸¥æ ¼
    negative: -0.2
  toxicity:
    warning: 0.6
```

**ä½¿ç”¨æ–¹å¼**ï¼š

java

å¤åˆ¶

```java
@Service
public class MockAIService {
    private final AnalysisThresholdConfig config;
    
    public List<AnalyzedMessage> analyzeBatch(List<SocialMessage> messages) {
        // ...
        String sentimentLabel = sentimentScore > config.getPositiveThreshold() ? "Positive" 
            : (sentimentScore < config.getNegativeThreshold() ? "Negative" : "Neutral");
        // ...
    }
}
```

### **2. åŠ¨æ€åˆ·æ–°ï¼ˆé«˜çº§ï¼‰**

ä½¿ç”¨ **Spring Cloud Config** æˆ– **Nacos** å®ç°çƒ­æ›´æ–°ï¼š

java

å¤åˆ¶

```java
@Component
@RefreshScope // Spring Cloud Config æ³¨è§£
public class AnalysisThresholdConfig {
    // é…ç½®ç±»åŒä¸Š
}
```

**ä¼˜åŠ¿**ï¼š

- æ— éœ€é‡å¯æœåŠ¡å³å¯è°ƒæ•´é˜ˆå€¼
    
- æ”¯æŒç°åº¦å‘å¸ƒå’ŒA/Bæµ‹è¯•
    

### **3. æ•°æ®é©±åŠ¨ä¼˜åŒ–ï¼ˆä¸“å®¶çº§ï¼‰**

é˜ˆå€¼ä¸åº”å‡­ç»éªŒè®¾å®šï¼Œè€Œåº”**åŸºäºæ•°æ®åˆ†å¸ƒ**ï¼š

java

å¤åˆ¶

```java
@Service
public class AdaptiveThresholdService {
    private final Histogram sentimentHistogram = new Histogram(...);
    
    public void updateThresholds(List<AnalyzedMessage> historicalData) {
        // è®¡ç®—å†å²æ•°æ®çš„90åˆ†ä½æ•°ä½œä¸ºæ­£é˜ˆå€¼
        double newPositiveThreshold = sentimentHistogram.getPercentile(0.9);
        // æŒä¹…åŒ–åˆ°é…ç½®ä¸­å¿ƒ
    }
}
```

**ä¼˜åŒ–å»ºè®®**ï¼š

- **æƒ…æ„Ÿé˜ˆå€¼**ï¼šä½¿ç”¨éªŒè¯é›†è®¡ç®—F1åˆ†æ•°ï¼Œé€‰æ‹©æœ€ä½³åˆ†ç•Œç‚¹
    
- **æ¯’æ€§é˜ˆå€¼**ï¼šæ ¹æ®ä¸šåŠ¡å®¹å¿åº¦ï¼Œç”¨ROCæ›²çº¿å¹³è¡¡å¬å›ç‡å’Œå‡†ç¡®ç‡
    
- **ç›‘æ§å‘Šè­¦**ï¼šå½“é˜ˆå€¼å‘½ä¸­ç‡ä½äº5%æˆ–é«˜äº95%æ—¶è§¦å‘å‘Šè­¦ï¼ˆé˜ˆå€¼å¯èƒ½ä¸åˆç†ï¼‰
    

### **4. å¤šç»´åº¦é˜ˆå€¼**

æ›´ç²¾ç»†çš„ç­–ç•¥ï¼š**æŒ‰è¯é¢˜/ç”¨æˆ·ç¾¤ä½“è®¾ç½®ä¸åŒé˜ˆå€¼**

java

å¤åˆ¶

```java
public class TopicSpecificThreshold {
    private Map<String, ThresholdConfig> thresholds = Map.of(
        "politics", new ThresholdConfig(0.5, -0.1, 0.5), // æ”¿æ²»è¯é¢˜æ›´æ•æ„Ÿ
        "entertainment", new ThresholdConfig(0.2, -0.4, 0.8) // å¨±ä¹è¯é¢˜æ›´å®½æ¾
    );
    
    public ThresholdConfig getConfig(String topic) {
        return thresholds.getOrDefault(topic, DEFAULT);
    }
}
```

---

## ä¸‰ã€æ€»ç»“

**æ‰¹å¤„ç†ä¼˜åŒ–è·¯å¾„**ï¼šæ‰‹åŠ¨ Buffer â†’ çª—å£èšåˆ â†’ çŠ¶æ€å­˜å‚¨ â†’ åŠ¨æ€æ‰©ç¼©å®¹

**é˜ˆå€¼è°ƒæ•´è·¯å¾„**ï¼šç¡¬ç¼–ç  â†’ é…ç½®åŒ– â†’ åŠ¨æ€åˆ·æ–° â†’ è‡ªé€‚åº”ç®—æ³•

**ç”Ÿäº§ç¯å¢ƒå»ºè®®**ï¼š

1. ç«‹å³å®æ–½**é…ç½®åŒ–**ï¼Œé¿å…ç¡¬ç¼–ç 
    
2. åœ¨ä¸­æœŸå¼•å…¥**åŠ¨æ€é…ç½®ä¸­å¿ƒ**
    
3. é•¿æœŸå»ºç«‹**æ•°æ®é©±åŠ¨çš„é˜ˆå€¼ä¼˜åŒ–**æµç¨‹
    
4. æ‰¹å¤„ç†ä¼˜åŒ–è‹¥æ•°æ®é‡å¤§ï¼Œä¼˜å…ˆå®ç°**repartition**ï¼Œå†è€ƒè™‘**çª—å£èšåˆ**